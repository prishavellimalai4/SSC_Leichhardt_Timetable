<!DOCTYPE html>
<!--
Tempe High School Timetable Kiosk
Copyright (C) 2025 TempeHS

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
    <title id="page-title">Loading...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; connect-src 'self' file:; img-src 'self' https://tempe-h.schools.nsw.gov.au data:;">
    <style id="dynamic-styles">
        /* Styles will be loaded dynamically from config */
    </style>
    <style>
        /* Base styles that don't depend on config */
    </style>
</head>
<body>
    <div class="loading-indicator" id="loading-indicator"></div>
    <div id="header"></div>
    <div id="timetable"></div>
    <div id="current-time"></div>
    <script>
        // Global configuration object
        let CONFIG = null;
        
        // --- CONFIGURATION LOADING ---
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                CONFIG = await response.json();
                
                // Apply configuration to page
                applyConfiguration();
                
                return CONFIG;
            } catch (error) {
                console.error('Error loading configuration:', error);
                // Fall back to default Tempe HS configuration
                CONFIG = getDefaultConfig();
                applyConfiguration();
                return CONFIG;
            }
        }
        
        function getDefaultConfig() {
            // Default configuration for Tempe HS (fallback)
            return {
                "school": {
                    "name": "Tempe High School",
                    "logo": {
                        "url": "https://tempe-h.schools.nsw.gov.au/content/dam/doe/sws/schools/t/tempe-h/logo.png",
                        "opacity": 0.15,
                        "size": "auto 100vh"
                    }
                },
                "colors": {
                    "primary": "#AC0000",
                    "background": "#f7f8fc",
                    "overlay": "rgba(247, 248, 252, 0.3)",
                    "tile": {
                        "background": "#EDEDEE",
                        "border": "#555",
                        "shadow": "#b5b7b9",
                        "hover": "#EDEDEE"
                    },
                    "text": {
                        "primary": "#1a2325",
                        "secondary": "#b5b7b9",
                        "classCode": "#AC0000"
                    }
                },
                "schedule": {
                    "ignoredDays": [0, 6],
                    "schoolDays": [1, 2, 3, 4, 5],
                    "defaultShowMinutesBefore": 10,
                    "periods": {
                        "P0": {
                            "showFromDay": 5,
                            "showFromTime": "15:05",
                            "showUntilStart": true,
                            "description": "Period 0"
                        },
                        "P1": {
                            "showFromTime": "08:20",
                            "description": "Period 1"
                        }
                    }
                },
                "sportPeriods": {
                    "tuesday": {
                        "periods": ["P5", "P6"],
                        "yearGroups": {
                            "7": {
                                "label": "Year 7 & 8 Sport",
                                "includesYears": [7, 8],
                                "excludeYears": [8]
                            },
                            "9": {
                                "label": "Year 9 & 10 Sport", 
                                "includesYears": [9, 10],
                                "excludeYears": [10]
                            }
                        }
                    }
                },
                "yearGroups": {
                    "multiRowYears": [7, 9],
                    "displayYears": [7, 8, 9, 10, 11, 12],
                    "classCodePattern": "^(\\d+)"
                },
                "ui": {
                    "refreshInterval": 60000,
                    "cacheBusting": true
                },
                "files": {
                    "bellTimes": "bell_times.xml",
                    "lessons": "liss_info.xml",
                    "calendar": "calendar.xml"
                }
            };
        }
        
        function applyConfiguration() {
            if (!CONFIG) return;
            
            // Set page title
            document.getElementById('page-title').textContent = CONFIG.school.name;
            
            // Generate dynamic CSS
            const css = generateDynamicCSS();
            document.getElementById('dynamic-styles').innerHTML = css;
        }
        
        function generateDynamicCSS() {
            const c = CONFIG.colors;
            const logo = CONFIG.school.logo;
            
            return `
                body { 
                    font-family: Arial, sans-serif; 
                    background: ${c.background};
                    margin: 0;
                    position: relative;
                }
                body::before {
                    content: '';
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-image: url('${logo.url}');
                    background-repeat: no-repeat;
                    background-position: center center;
                    background-size: ${logo.size};
                    opacity: ${logo.opacity};
                    z-index: -1;
                    pointer-events: none;
                }
                body::after {
                    content: '';
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: ${c.overlay};
                    z-index: -1;
                    pointer-events: none;
                }
                h2 { text-align: center; font-size: 1.5rem }
                .year-section { margin: 20px 20px 20px 32px; }
                .year-label {
                    display: block;
                    font-weight: bold;
                    font-size: 1.25em;
                    margin-bottom: 10px;
                    text-align: left;
                    color: ${c.primary};
                    padding-left: 12px;
                }
                .tiles {
                    display: flex;
                    flex-direction: row;
                    flex-wrap: nowrap;
                    gap: 10px;
                    margin-bottom: 18px;
                    overflow-x: auto;
                }
                .tiles.multi-row {
                    flex-wrap: wrap;
                    overflow-x: visible;
                    max-height: none;
                }
                .tile {
                    background: ${c.tile.background};
                    border: 1px solid ${c.tile.border};
                    border-radius: 11px;
                    min-width: 300px;
                    max-width: 320px;
                    min-height: 56px;
                    padding: 7px 5px;
                    box-shadow: 2px 2px 6px ${c.tile.shadow};
                    display: flex;
                    flex-direction: column;
                    align-items: flex-start;
                    justify-content: center;
                    transition: box-shadow 0.2s;
                }
                .tile:hover {
                    box-shadow: 2px 6px 16px ${c.tile.hover};
                }
                .classcode { font-weight: bold; font-size: 3em; color: ${c.text.classCode}; margin-bottom: 2px; }
                .room { font-size: 2em; color: ${c.text.primary}; margin-bottom: 2px; }
                .teacher { font-size: 2em; color: ${c.text.primary}; }
                .empty-row {
                    color: ${c.text.secondary};
                    font-style: italic;
                    text-align: center;
                    padding: 14px 0;
                }
                #current-time {
                    text-align: right;
                    font-size: 0.9em;
                    color: ${c.text.primary};
                    margin: 20px 12px 10px 0;
                    transition: opacity 0.3s ease;
                }
                #current-time.manual-override {
                    color: #d73502;
                    font-weight: bold;
                    background: #fff3cd;
                    padding: 5px 10px;
                    border-radius: 4px;
                    border: 1px solid #ffeaa7;
                }
                #current-time.updating {
                    opacity: 0.5;
                }
                
                /* Smooth transition for content updates */
                #header, #timetable {
                    transition: opacity 0.2s ease-in-out;
                }
                
                /* Subtle loading indicator */
                .loading-indicator {
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: ${c.primary};
                    opacity: 0;
                    z-index: 1000;
                    transition: opacity 0.3s ease-in-out;
                }
                
                /* Only animate when visible */
                .loading-indicator.visible {
                    animation: pulse 1s infinite;
                }
                
                @keyframes pulse {
                    0%, 100% { opacity: 0.3; transform: scale(1); }
                    50% { opacity: 0.8; transform: scale(1.2); }
                }
                
                /* Responsive breakpoints - will be overridden by config if specified */
                @media (max-width: 1700px) {
                    .tiles { gap: 8px;}
                }
                @media (max-width: 1280px) {
                    .tiles { gap: 6px;}
                }
                @media (max-width: 700px) {
                    .year-section { max-width: 99vw; }
                    .tiles { gap: 4px;}
                    .tile { min-width: 90px; max-width: 100px;}
                }
                
                /* Responsive height breakpoint - compact layout for short screens */
                @media (max-height: ${CONFIG.ui.responsive.breakpoints.compactHeight}px) {
                    .year-section {
                        display: flex;
                        flex-direction: row;
                        align-items: flex-start;
                        gap: 10px;
                        margin: 20px 15px 20px 15px;
                    }
                    
                    .year-label {
                        flex-shrink: 0;
                        min-width: 80px;
                        max-width: 120px;
                        margin-bottom: 0;
                        margin-top: 8px;
                        writing-mode: horizontal-tb;
                        text-align: right;
                        padding-left: 0;
                        padding-right: 12px;
                    }
                    
                    .tiles {
                        flex: 1;
                        margin-bottom: 0;
                    }
                    
                    .tiles.multi-row {
                        max-height: 200px;
                        overflow-y: auto;
                        overflow-x: visible;
                    }
                }
                
                /* Original layout for tall screens */
                @media (min-height: ${CONFIG.ui.responsive.breakpoints.compactHeight + 1}px) {
                    .year-section {
                        display: block;
                        margin: 20px 20px 20px 32px;
                    }
                    
                    .year-label {
                        display: block;
                        margin-bottom: 10px;
                        writing-mode: horizontal-tb;
                        text-align: left;
                        padding-left: 12px;
                        padding-right: 0;
                    }
                    
                    .tiles {
                        margin-bottom: 18px;
                    }
                }
            `;
        }

        // --- MANUAL OVERRIDE FOR TESTING ---
        // 
        // INSTRUCTIONS FOR TESTING:
        // 1. Set USE_MANUAL_OVERRIDE to true
        // 2. Set MANUAL_DATE to the desired date (month is 0-indexed: 0=Jan, 1=Feb, etc.)
        // 3. Set MANUAL_TIME_HOURS (24-hour format: 0-23)
        // 4. Set MANUAL_TIME_MINUTES (0-59)
        // 5. Refresh the page to see the timetable for that date/time
        // 
        // EXAMPLES:
        // - Tuesday P5: new Date(2025, 7, 12), HOURS=13, MINUTES=25 (1:25 PM)
        // - Friday 3:05 PM: new Date(2025, 7, 15), HOURS=15, MINUTES=5
        // - Monday P0: new Date(2025, 7, 11), HOURS=7, MINUTES=45
        //
        const USE_MANUAL_OVERRIDE = false;
        
        // Manual date/time settings (only used when USE_MANUAL_OVERRIDE is true)
        const MANUAL_DATE = new Date(2025, 8, 25); // August 12, 2025 (month is 0-indexed)
        const MANUAL_TIME_HOURS = 8; // 1 PM
        const MANUAL_TIME_MINUTES = 20; // 25 minutes
        
        // Function to get current time (real or overridden)
        function getCurrentTime() {
            if (USE_MANUAL_OVERRIDE) {
                const manualDateTime = new Date(MANUAL_DATE);
                manualDateTime.setHours(MANUAL_TIME_HOURS, MANUAL_TIME_MINUTES, 0, 0);
                return manualDateTime;
            }
            return new Date();
        }
        
        // --- UTILS ---
        const pad2 = n => n < 10 ? '0' + n : n;
        const auDate = date => `${pad2(date.getDate())}/${pad2(date.getMonth() + 1)}/${date.getFullYear()}`;
        const longDay = date => date.toLocaleDateString('en-AU', { weekday: 'long' });

        // Given a date, return the next school day (skips ignored days from config)
        function getNextSchoolDay(date) {
            if (!CONFIG) return date;
            
            let nextDate = new Date(date);
            let dow = nextDate.getDay();
            
            // Keep incrementing until we find a school day
            while (CONFIG.schedule.ignoredDays.includes(dow)) {
                nextDate.setDate(nextDate.getDate() + 1);
                dow = nextDate.getDay();
            }
            
            // If we're already on a school day, move to the next school day
            if (CONFIG.schedule.schoolDays.includes(dow) && nextDate.toDateString() === date.toDateString()) {
                nextDate.setDate(nextDate.getDate() + 1);
                dow = nextDate.getDay();
                
                // Skip any ignored days again
                while (CONFIG.schedule.ignoredDays.includes(dow)) {
                    nextDate.setDate(nextDate.getDate() + 1);
                    dow = nextDate.getDay();
                }
            }
            
            return nextDate;
        }

        // --- XML LOADING ---
        function loadXML(path) {
            // Add cache busting timestamp if enabled in config
            let urlWithCacheBuster = path;
            if (CONFIG && CONFIG.ui.cacheBusting) {
                const cacheBuster = `?t=${Date.now()}`;
                urlWithCacheBuster = path + cacheBuster;
            }
            
            return fetch(urlWithCacheBuster)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(str => {
                    const parser = new window.DOMParser();
                    const xml = parser.parseFromString(str, "text/xml");
                    
                    // Check for XML parsing errors
                    const parseError = xml.getElementsByTagName("parsererror")[0];
                    if (parseError) {
                        throw new Error(`XML Parse Error: ${parseError.textContent}`);
                    }
                    
                    return xml;
                })
                .catch(error => {
                    console.error("Error loading XML:", error);
                    
                    // Provide helpful error message for CORS issues
                    if (error.message.includes('CORS') || error.message.includes('fetch')) {
                        throw new Error(`CORS Error: Cannot load local files. Please run this application using a local web server. See instructions below.`);
                    }
                    
                    throw error;
                });
        }

        // --- DATA PARSING ---
        // Helper function to extract member values from XML
        function extractMemberValue(members, memberName) {
            for(let j = 0; j < members.length; j++) {
                const member = members[j];
                const nameEl = member.getElementsByTagName("name")[0];
                const valueEl = member.getElementsByTagName("value")[0];
                
                if(nameEl && valueEl && nameEl.textContent === memberName) {
                    return valueEl.textContent;
                }
            }
            return null;
        }

        // Helper function to check if JSON data is stale (older than 7 days)
        function isDataStale(metadata, maxAgeDays = 7) {
            if (!metadata) return true;
            
            // Try different metadata timestamp formats
            const timestamp = metadata.generated_at || metadata.generated || metadata.timestamp;
            if (!timestamp) {
                debugWarn('‚ö†Ô∏è  STALE CHECK: No timestamp found in metadata');
                return true;
            }
            
            try {
                const generatedDate = new Date(timestamp);
                const now = new Date();
                const ageInDays = (now - generatedDate) / (1000 * 60 * 60 * 24);
                
                debugLog(`üïê STALE CHECK: Data generated at ${timestamp}, age: ${ageInDays.toFixed(1)} days`);
                
                if (ageInDays > maxAgeDays) {
                    debugWarn(`‚ö†Ô∏è  STALE CHECK: Data is ${ageInDays.toFixed(1)} days old (exceeds ${maxAgeDays} day limit)`);
                    return true;
                }
                
                debugLog(`‚úÖ STALE CHECK: Data is fresh (${ageInDays.toFixed(1)} days old)`);
                return false;
            } catch (error) {
                debugError('‚ùå STALE CHECK: Error parsing timestamp:', error.message);
                return true;
            }
        }

        // Load bell times data from JSON or XML based on configuration
        async function loadBellTimesData() {
            debugLog('üîß BELL TIMES DEBUG: Starting bell times data loading...');
            
            if (!CONFIG) {
                debugError('‚ùå BELL TIMES DEBUG: No CONFIG available');
                return null;
            }
            
            // Use centralized API configuration and data source specific settings
            const apiConfig = CONFIG.api || {};
            const bellTimesConfig = CONFIG.dataSources?.bell_times || {};
            const useAPI = apiConfig.use_json !== false; // Default to true
            const fallbackToXML = apiConfig.fallback_to_xml !== false; // Default to true
            const apiFile = bellTimesConfig.json_file || 'bell_times.json';
            const xmlFile = bellTimesConfig.xml_file || 'bell_times.xml';
            const staleDataThreshold = apiConfig.sync_days || 7; // Use centralized sync_days
            
            // Debug configuration
            debugLog('üîß BELL TIMES DEBUG: Configuration:', {
                'use_json': useAPI,
                'fallback_to_xml': fallbackToXML,
                'json_file': apiFile,
                'xml_file': xmlFile,
                'sync_days': staleDataThreshold,
                'cache_busting': CONFIG.ui.cacheBusting
            });
            
            // Try JSON API source first if enabled
            if (useAPI) {
                try {
                    debugLog('‚è∞ BELL TIMES DEBUG: Attempting to load bell times from JSON API source...');
                    debugLog(`üìÅ BELL TIMES DEBUG: Trying to fetch: ${apiFile}`);
                    
                    let urlWithCacheBuster = apiFile;
                    if (CONFIG.ui.cacheBusting) {
                        urlWithCacheBuster += `?t=${Date.now()}`;
                        debugLog(`üîÑ BELL TIMES DEBUG: Cache busting enabled, URL: ${urlWithCacheBuster}`);
                    }
                    
                    const response = await fetch(urlWithCacheBuster);
                    debugLog(`üìä BELL TIMES DEBUG: JSON fetch response status: ${response.status}`);
                    
                    if (response.ok) {
                        const jsonData = await response.json();
                        debugLog('‚úÖ BELL TIMES DEBUG: Successfully loaded bell times from JSON API source');
                        debugLog(`üìà BELL TIMES DEBUG: JSON contains ${jsonData.bell_times?.length || 0} bell time entries`);
                        
                        // Check if JSON data is stale using centralized sync_days
                        if (isDataStale(jsonData.metadata, staleDataThreshold)) {
                            debugWarn(`‚ö†Ô∏è  BELL TIMES DEBUG: JSON data is stale (older than ${staleDataThreshold} days), falling back to XML`);
                            throw new Error('JSON data is stale');
                        }
                        
                        const result = parseBellTimesJSON(jsonData);
                        debugLog('üéØ BELL TIMES DEBUG: Final decision - USING JSON BELL TIMES');
                        return result;
                    } else {
                        debugWarn(`‚ö†Ô∏è  BELL TIMES DEBUG: JSON bell times file ${apiFile} not found (${response.status})`);
                    }
                } catch (error) {
                    debugWarn('‚ö†Ô∏è  BELL TIMES DEBUG: Error loading JSON bell times:', error.message);
                }
            } else {
                debugLog('üö´ BELL TIMES DEBUG: JSON API loading disabled in configuration');
            }
            
            // Fallback to XML if enabled and JSON failed or wasn't tried
            if (fallbackToXML) {
                try {
                    debugLog('‚è∞ BELL TIMES DEBUG: Falling back to XML bell times source...');
                    debugLog(`üìÅ BELL TIMES DEBUG: Trying to fetch XML: ${xmlFile}`);
                    
                    const bellTimesXML = await loadXML(xmlFile);
                    debugLog('‚úÖ BELL TIMES DEBUG: Successfully loaded bell times from XML fallback source');
                    const result = parseBellTimesXML(bellTimesXML);
                    debugLog('üéØ BELL TIMES DEBUG: Final decision - USING XML BELL TIMES');
                    return result;
                } catch (error) {
                    debugError('‚ùå BELL TIMES DEBUG: Error loading XML bell times:', error.message);
                    throw error;
                }
            } else {
                debugLog('üö´ BELL TIMES DEBUG: XML fallback disabled in configuration');
            }
            
            debugError('‚ùå BELL TIMES DEBUG: No bell times sources available or enabled');
            throw new Error('No bell times sources available or enabled');
        }
        
        // Parse JSON bell times format (from Sentral API)
        function parseBellTimesJSON(jsonData) {
            debugLog('üîß BELL TIMES DEBUG: Starting JSON bell times parsing...');
            
            if (!jsonData || !jsonData.bell_times) {
                debugError('‚ùå BELL TIMES DEBUG: Invalid JSON bell times format - missing bell_times array');
                debugLog('üîç BELL TIMES DEBUG: JSON data structure:', jsonData);
                return [];
            }
            
            debugLog(`üìä BELL TIMES DEBUG: JSON metadata:`, jsonData.metadata);
            debugLog(`üìã BELL TIMES DEBUG: Processing ${jsonData.bell_times.length} JSON bell time entries`);
            
            const periods = [];
            for (const entry of jsonData.bell_times) {
                if (entry.Period && entry.StartTime && entry.EndTime) {
                    periods.push({
                        period: entry.Period,
                        start: parseTime(entry.StartTime),
                        end: parseTime(entry.EndTime),
                        dayName: entry.DayName,
                        dayNumber: entry.DayNumber,
                        type: entry.Type,
                        source: 'api'
                    });
                } else {
                    debugWarn('‚ö†Ô∏è  BELL TIMES DEBUG: Skipping invalid JSON entry:', entry);
                }
            }
            
            debugLog(`‚úÖ BELL TIMES DEBUG: Successfully parsed ${periods.length} JSON bell time entries`);
            debugLog('üìã BELL TIMES DEBUG: Sample entries:', periods.slice(0, 3));
            return periods;
        }
        
        // Parse XML bell times format (existing format)
        function parseBellTimesXML(xml) {
            debugLog('üîß BELL TIMES DEBUG: Starting XML bell times parsing...');
            
            const periods = [];
            const nodes = xml.getElementsByTagName("struct");
            debugLog(`üìã BELL TIMES DEBUG: Found ${nodes.length} XML struct nodes to process`);
            
            for(let i = 0; i < nodes.length; i++) {
                const members = nodes[i].getElementsByTagName("member");
                
                const periodName = extractMemberValue(members, "Period");
                const startTime = extractMemberValue(members, "StartTime");
                const endTime = extractMemberValue(members, "EndTime");
                const dayName = extractMemberValue(members, "DayName");
                const dayNumber = extractMemberValue(members, "DayNumber");
                const type = extractMemberValue(members, "Type");
                
                if(periodName && startTime && endTime) {
                    periods.push({
                        period: periodName,
                        start: parseTime(startTime),
                        end: parseTime(endTime),
                        dayName: dayName,
                        dayNumber: dayNumber ? parseInt(dayNumber) : null,
                        type: type,
                        source: 'xml'
                    });
                } else {
                    debugWarn('‚ö†Ô∏è  BELL TIMES DEBUG: Missing XML fields in entry:', {periodName, startTime, endTime});
                }
            }
            
            debugLog(`‚úÖ BELL TIMES DEBUG: Successfully parsed ${periods.length} XML bell time entries`);
            debugLog('üìã BELL TIMES DEBUG: Sample entries:', periods.slice(0, 3));
            return periods;
        }

        // Legacy function for backward compatibility - now uses new loader
        function parseBellTimes(xml) {
            return parseBellTimesXML(xml);
        }
        
        function parseTime(timeStr) {
            if(!timeStr) return 0;
            const [hours, minutes] = timeStr.split(":").map(Number);
            return hours * 60 + minutes;
        }
        
        // --- CALENDAR DATA LOADING ---
        // Debug logging function - only logs if debug is enabled in config
        function debugLog(message, ...args) {
            if (CONFIG && CONFIG.ui && CONFIG.ui.debug) {
                console.log(message, ...args);
            }
        }
        
        function debugWarn(message, ...args) {
            if (CONFIG && CONFIG.ui && CONFIG.ui.debug) {
                console.warn(message, ...args);
            }
        }
        
        function debugError(message, ...args) {
            if (CONFIG && CONFIG.ui && CONFIG.ui.debug) {
                console.error(message, ...args);
            }
        }
        
        // Load calendar data from JSON or XML based on configuration
        async function loadCalendarData() {
            debugLog('üîß CALENDAR DEBUG: Starting calendar data loading...');
            
            if (!CONFIG) {
                debugError('‚ùå CALENDAR DEBUG: No CONFIG available');
                return null;
            }
            
            // Use centralized API configuration and data source specific settings
            const apiConfig = CONFIG.api || {};
            const calendarConfig = CONFIG.dataSources?.calendar || {};
            const useAPI = apiConfig.use_json !== false; // Default to true
            const fallbackToXML = apiConfig.fallback_to_xml !== false; // Default to true
            const apiFile = calendarConfig.json_file || 'calendar.json';
            const xmlFile = calendarConfig.xml_file || 'calendar.xml';
            const staleDataThreshold = apiConfig.sync_days || 7; // Use centralized sync_days
            
            // Debug configuration
            debugLog('üîß CALENDAR DEBUG: Configuration:', {
                'use_json': useAPI,
                'fallback_to_xml': fallbackToXML,
                'json_file': apiFile,
                'xml_file': xmlFile,
                'sync_days': staleDataThreshold,
                'cache_busting': CONFIG.ui.cacheBusting
            });
            
            // Try JSON API source first if enabled
            if (useAPI) {
                try {
                    debugLog('üóìÔ∏è  CALENDAR DEBUG: Attempting to load calendar from JSON API source...');
                    debugLog(`üìÅ CALENDAR DEBUG: Trying to fetch: ${apiFile}`);
                    
                    let urlWithCacheBuster = apiFile;
                    if (CONFIG.ui.cacheBusting) {
                        urlWithCacheBuster += `?t=${Date.now()}`;
                        debugLog(`üîÑ CALENDAR DEBUG: Cache busting enabled, URL: ${urlWithCacheBuster}`);
                    }
                    
                    const response = await fetch(urlWithCacheBuster);
                    debugLog(`üìä CALENDAR DEBUG: JSON fetch response status: ${response.status}`);
                    
                    if (response.ok) {
                        const jsonData = await response.json();
                        debugLog('‚úÖ CALENDAR DEBUG: Successfully loaded calendar from JSON API source');
                        debugLog(`üìà CALENDAR DEBUG: JSON contains ${jsonData.calendar?.length || 0} calendar entries`);
                        
                        // Check if JSON data is stale using centralized sync_days
                        if (isDataStale(jsonData.metadata, staleDataThreshold)) {
                            debugWarn(`‚ö†Ô∏è  CALENDAR DEBUG: JSON data is stale (older than ${staleDataThreshold} days), falling back to XML`);
                            throw new Error('JSON data is stale');
                        }
                        
                        const result = parseCalendarJSON(jsonData);
                        debugLog('üéØ CALENDAR DEBUG: Final decision - USING JSON CALENDAR');
                        return result;
                    } else {
                        debugWarn(`‚ö†Ô∏è  CALENDAR DEBUG: JSON calendar file ${apiFile} not found (${response.status})`);
                    }
                } catch (error) {
                    debugWarn('‚ö†Ô∏è  CALENDAR DEBUG: Error loading JSON calendar:', error.message);
                }
            } else {
                debugLog('üö´ CALENDAR DEBUG: JSON API loading disabled in configuration');
            }
            
            // Fallback to XML if enabled and JSON failed or wasn't tried
            if (fallbackToXML) {
                try {
                    debugLog('üóìÔ∏è  CALENDAR DEBUG: Falling back to XML calendar source...');
                    debugLog(`üìÅ CALENDAR DEBUG: Trying to fetch XML: ${xmlFile}`);
                    
                    const calendarXML = await loadXML(xmlFile);
                    debugLog('‚úÖ CALENDAR DEBUG: Successfully loaded calendar from XML fallback source');
                    const result = parseCalendarXML(calendarXML);
                    debugLog('üéØ CALENDAR DEBUG: Final decision - USING XML CALENDAR');
                    return result;
                } catch (error) {
                    debugError('‚ùå CALENDAR DEBUG: Error loading XML calendar:', error.message);
                    throw error;
                }
            } else {
                debugLog('üö´ CALENDAR DEBUG: XML fallback disabled in configuration');
            }
            
            debugError('‚ùå CALENDAR DEBUG: No calendar sources available or enabled');
            throw new Error('No calendar sources available or enabled');
        }
        
        // Parse JSON calendar format (from Sentral API)
        function parseCalendarJSON(jsonData) {
            debugLog('üîß CALENDAR DEBUG: Starting JSON calendar parsing...');
            
            if (!jsonData || !jsonData.calendar) {
                debugError('‚ùå CALENDAR DEBUG: Invalid JSON calendar format - missing calendar array');
                debugLog('üîç CALENDAR DEBUG: JSON data structure:', jsonData);
                return [];
            }
            
            debugLog(`üìä CALENDAR DEBUG: JSON metadata:`, jsonData.metadata);
            debugLog(`üìã CALENDAR DEBUG: Processing ${jsonData.calendar.length} JSON calendar entries`);
            
            const calendar = [];
            for (const entry of jsonData.calendar) {
                if (entry.date && entry.day_name && entry.day_number !== undefined) {
                    calendar.push({
                        date: new Date(entry.date + 'T00:00:00'), // Ensure proper date parsing
                        dayName: entry.day_name,
                        dayNumber: entry.day_number,
                        isSchoolDay: entry.is_school_day,
                        dayType: entry.day_type,
                        cycle: entry.cycle,
                        source: 'api'
                    });
                } else {
                    debugWarn('‚ö†Ô∏è  CALENDAR DEBUG: Skipping invalid JSON entry:', entry);
                }
            }
            
            debugLog(`‚úÖ CALENDAR DEBUG: Successfully parsed ${calendar.length} JSON calendar entries`);
            debugLog('üìã CALENDAR DEBUG: Sample entries:', calendar.slice(0, 3));
            return calendar;
        }
        
        // Parse XML calendar format (existing format)
        function parseCalendarXML(xml) {
            debugLog('üîß CALENDAR DEBUG: Starting XML calendar parsing...');
            
            const calendar = [];
            const nodes = xml.getElementsByTagName("struct");
            debugLog(`üìã CALENDAR DEBUG: Found ${nodes.length} XML struct nodes to process`);
            
            for(let i = 0; i < nodes.length; i++) {
                const members = nodes[i].getElementsByTagName("member");
                
                const dateStr = extractMemberValue(members, "Date");
                const dayName = extractMemberValue(members, "DayName");
                const dayNumber = extractMemberValue(members, "DayNumber");
                
                if(dateStr && dayName && dayNumber) {
                    // Parse ISO date format: 20250811T00:00:00
                    const dateMatch = dateStr.match(/(\d{4})(\d{2})(\d{2})T/);
                    if(dateMatch) {
                        calendar.push({
                            date: new Date(dateMatch[1], dateMatch[2] - 1, dateMatch[3]),
                            dayName: dayName,
                            dayNumber: parseInt(dayNumber),
                            isSchoolDay: dayName !== 'weekend' && dayName !== 'holiday',
                            dayType: dayName,
                            source: 'xml'
                        });
                    } else {
                        debugWarn('‚ö†Ô∏è  CALENDAR DEBUG: Invalid XML date format:', dateStr);
                    }
                } else {
                    debugWarn('‚ö†Ô∏è  CALENDAR DEBUG: Missing XML fields in entry:', {dateStr, dayName, dayNumber});
                }
            }
            
            debugLog(`‚úÖ CALENDAR DEBUG: Successfully parsed ${calendar.length} XML calendar entries`);
            debugLog('üìã CALENDAR DEBUG: Sample entries:', calendar.slice(0, 3));
            return calendar;
        }

        function getDayNumber(calendarData, targetDate) {
            const entry = calendarData.find(entry => {
                const entryDate = new Date(entry.date);
                return entryDate.toDateString() === targetDate.toDateString();
            });
            
            return entry ? entry.dayNumber : null;
        }
        
        // --- LISS DATA LOADING (JSON/XML DUAL SOURCE) ---
        async function loadLissData() {
            debugLog('üîß LISS DEBUG: Starting LISS data loading...');
            
            if (!CONFIG) {
                debugError('‚ùå LISS DEBUG: No CONFIG available');
                return null;
            }
            
            // Use centralized API configuration and data source specific settings
            const apiConfig = CONFIG.api || {};
            const lissConfig = CONFIG.dataSources?.liss_info || {};
            const useAPI = apiConfig.use_json !== false; // Default to true
            const fallbackToXML = apiConfig.fallback_to_xml !== false; // Default to true
            const apiFile = lissConfig.json_file || 'liss_info.json';
            const xmlFile = lissConfig.xml_file || 'liss_info.xml';
            const staleDataThreshold = apiConfig.sync_days || 7; // Use centralized sync_days
            
            // Debug configuration
            debugLog('üîß LISS DEBUG: Configuration:', {
                'use_json': useAPI,
                'fallback_to_xml': fallbackToXML,
                'json_file': apiFile,
                'xml_file': xmlFile,
                'sync_days': staleDataThreshold,
                'cache_busting': CONFIG.ui.cacheBusting
            });
            
            // Try JSON API source first if enabled
            if (useAPI) {
                try {
                    debugLog('üìö LISS DEBUG: Attempting to load LISS data from JSON API source...');
                    debugLog(`üìÅ LISS DEBUG: Trying to fetch: ${apiFile}`);
                    
                    let urlWithCacheBuster = apiFile;
                    if (CONFIG.ui.cacheBusting) {
                        urlWithCacheBuster += `?t=${Date.now()}`;
                        debugLog(`üîÑ LISS DEBUG: Cache busting enabled, URL: ${urlWithCacheBuster}`);
                    }
                    
                    const response = await fetch(urlWithCacheBuster);
                    debugLog(`üìä LISS DEBUG: JSON fetch response status: ${response.status}`);
                    
                    if (response.ok) {
                        const jsonData = await response.json();
                        debugLog('‚úÖ LISS DEBUG: Successfully loaded LISS data from JSON API source');
                        debugLog(`üìà LISS DEBUG: JSON contains ${jsonData.timetable_data?.length || 0} LISS entries`);
                        debugLog('üìã LISS DEBUG: JSON metadata:', jsonData.metadata);
                        
                        // Check if JSON data is stale using centralized sync_days
                        if (isDataStale(jsonData.metadata, staleDataThreshold)) {
                            debugWarn(`‚ö†Ô∏è  LISS DEBUG: JSON data is stale (older than ${staleDataThreshold} days), falling back to XML`);
                            throw new Error('JSON data is stale');
                        }
                        
                        const result = await parseLissJSON(jsonData);
                        debugLog('üéØ LISS DEBUG: Final decision - USING JSON LISS DATA');
                        return result;
                    } else {
                        debugWarn(`‚ö†Ô∏è  LISS DEBUG: JSON LISS file ${apiFile} not found (${response.status})`);
                    }
                } catch (error) {
                    debugWarn('‚ö†Ô∏è  LISS DEBUG: Error loading JSON LISS data:', error.message);
                }
            } else {
                debugLog('üö´ LISS DEBUG: JSON API loading disabled in configuration');
            }
            
            // Fallback to XML if enabled and JSON failed or wasn't tried
            if (fallbackToXML) {
                try {
                    debugLog('üìö LISS DEBUG: Falling back to XML LISS source...');
                    debugLog(`üìÅ LISS DEBUG: Trying to fetch XML: ${xmlFile}`);
                    
                    const lissXML = await loadXML(xmlFile);
                    debugLog('‚úÖ LISS DEBUG: Successfully loaded LISS data from XML fallback source');
                    debugLog('üéØ LISS DEBUG: Final decision - USING XML LISS DATA');
                    return lissXML;
                } catch (error) {
                    debugError('‚ùå LISS DEBUG: Error loading XML LISS data:', error.message);
                    throw error;
                }
            } else {
                debugLog('üö´ LISS DEBUG: XML fallback disabled in configuration');
            }
            
            debugError('‚ùå LISS DEBUG: No LISS data sources available or enabled');
            throw new Error('No LISS data sources available or enabled');
        }
        
        // Parse JSON LISS format (optimized Sentral API format)
        async function parseLissJSON(jsonData) {
            debugLog('üîß LISS DEBUG: Starting JSON LISS parsing...');
            
            if (!jsonData || !jsonData.timetable_data) {
                debugError('‚ùå LISS DEBUG: Invalid JSON LISS format - missing timetable_data array');
                debugLog('üîç LISS DEBUG: JSON data structure:', jsonData);
                return null;
            }
            
            debugLog(`üìä LISS DEBUG: JSON metadata:`, jsonData.metadata);
            debugLog(`üìã LISS DEBUG: Processing ${jsonData.timetable_data.length} JSON LISS entries`);
            
            // Convert JSON data to XML-like structure for compatibility with existing parseLessons function
            const xmlDoc = document.implementation.createDocument(null, 'root', null);
            const root = xmlDoc.documentElement;
            
            for (const entry of jsonData.timetable_data) {
                const structElement = xmlDoc.createElement('struct');
                
                // Create member elements for each property
                const members = [
                    { name: 'DayNumber', value: entry.DayNumber, type: 'int' },
                    { name: 'Period', value: entry.Period, type: 'string' },
                    { name: 'ClassCode', value: entry.ClassCode, type: 'string' },
                    { name: 'TeacherCode', value: entry.TeacherCode, type: 'string' },
                    { name: 'RoomCode', value: entry.RoomCode, type: 'string' }
                ];
                
                for (const member of members) {
                    const memberElement = xmlDoc.createElement('member');
                    const nameElement = xmlDoc.createElement('name');
                    nameElement.textContent = member.name;
                    
                    const valueElement = xmlDoc.createElement('value');
                    const typeElement = xmlDoc.createElement(member.type);
                    typeElement.textContent = member.value;
                    valueElement.appendChild(typeElement);
                    
                    memberElement.appendChild(nameElement);
                    memberElement.appendChild(valueElement);
                    structElement.appendChild(memberElement);
                }
                
                root.appendChild(structElement);
            }
            
            debugLog(`‚úÖ LISS DEBUG: Successfully converted ${jsonData.timetable_data.length} JSON entries to XML structure`);
            debugLog('üìã LISS DEBUG: Sample converted entries:', jsonData.timetable_data.slice(0, 3));
            
            // Add source metadata to the XML document
            xmlDoc.lissSource = 'api';
            xmlDoc.lissMetadata = jsonData.metadata;
            
            return xmlDoc;
        }

        function parseLessons(xml, currentPeriod, calendarData, targetDate) {
            const lessonsByYear = {};
            const nodes = xml.getElementsByTagName("struct");
            
            // Get the day number for the current date from calendar
            const dayNumber = getDayNumber(calendarData, targetDate);
            
            // Check if this is a sport period based on config
            const isSportPeriod = isConfiguredSportPeriod(calendarData, targetDate, currentPeriod);
            
            for(let i = 0; i < nodes.length; i++) {
                const members = nodes[i].getElementsByTagName("member");
                
                const lessonDayNumber = parseInt(extractMemberValue(members, "DayNumber"));
                const period = extractMemberValue(members, "Period");
                const classCode = extractMemberValue(members, "ClassCode");
                const teacherCode = extractMemberValue(members, "TeacherCode");
                const roomCode = extractMemberValue(members, "RoomCode");
                
                // Only include lessons for the current day number AND current period
                if(classCode && period === currentPeriod && lessonDayNumber === dayNumber) {
                    // Extract year from class code using config pattern
                    const classMatch = classCode.match(new RegExp(CONFIG.yearGroups.classCodePattern));
                    if(classMatch) {
                        const year = classMatch[1];
                        
                        // Skip years excluded during sport periods
                        if(isSportPeriod && shouldExcludeYearFromSport(year, calendarData, targetDate, currentPeriod)) {
                            continue;
                        }
                        
                        if (!lessonsByYear[year]) lessonsByYear[year] = [];
                        lessonsByYear[year].push({
                            ClassCode: classCode,
                            TeacherCode: teacherCode,
                            RoomCode: roomCode
                        });
                    }
                }
            }
            return lessonsByYear;
        }
        
        // Check if current period is configured as a sport period
        function isConfiguredSportPeriod(calendarData, targetDate, currentPeriod) {
            if (!CONFIG || !CONFIG.sportPeriods) return false;
            
            const calendarEntry = calendarData.find(entry => {
                const entryDate = new Date(entry.date);
                return entryDate.toDateString() === targetDate.toDateString();
            });
            
            if (!calendarEntry) return false;
            
            // Check each configured sport day
            for (const [dayKey, sportConfig] of Object.entries(CONFIG.sportPeriods)) {
                // Check if the calendar day name starts with the configured day key (e.g., 'TueB' starts with 'tue')
                if (calendarEntry.dayName.toLowerCase().startsWith(dayKey.toLowerCase().substring(0, 3)) && 
                    sportConfig.periods.includes(currentPeriod)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a year should be excluded from sport periods
        function shouldExcludeYearFromSport(year, calendarData, targetDate, currentPeriod) {
            if (!CONFIG || !CONFIG.sportPeriods) return false;
            
            const calendarEntry = calendarData.find(entry => {
                const entryDate = new Date(entry.date);
                return entryDate.toDateString() === targetDate.toDateString();
            });
            
            if (!calendarEntry) return false;
            
            // Check each configured sport day
            for (const [dayKey, sportConfig] of Object.entries(CONFIG.sportPeriods)) {
                if (calendarEntry.dayName.toLowerCase().startsWith(dayKey.toLowerCase().substring(0, 3)) && 
                    sportConfig.periods.includes(currentPeriod)) {
                    
                    // Check if this year should be excluded
                    for (const [groupYear, groupConfig] of Object.entries(sportConfig.yearGroups)) {
                        if (groupConfig.excludeYears && groupConfig.excludeYears.includes(parseInt(year))) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // --- PERIOD LOGIC ---
        // Show periods based on configuration
        function getCurrentPeriodOrNext(bellTimes, now) {
            if (!CONFIG) return {period: "P0", date: now, forceNextDay: false};
            
            const currentMinutes = now.getHours()*60 + now.getMinutes();
            const currentDay = now.getDay();
            let period = null;
            let foundPeriod = false;
            
            // Skip ignored days from config
            if (CONFIG.schedule.ignoredDays.includes(currentDay)) {
                let nextSchoolDay = getNextSchoolDay(now);
                const firstPeriod = bellTimes.length ? bellTimes[0].period : "P0";
                return {period: firstPeriod, date: nextSchoolDay, forceNextDay: true};
            }
            
            // Sort bell times by start time to ensure proper order
            const sortedBellTimes = bellTimes.slice().sort((a, b) => a.start - b.start);
            
            for (let i = 0; i < sortedBellTimes.length; i++) {
                const p = sortedBellTimes[i];
                let showFromTime;
                
                // Check if this period has special configuration
                const periodConfig = CONFIG.schedule.periods[p.period];
                
                if (periodConfig) {
                    if (periodConfig.showFromDay !== undefined && periodConfig.showFromTime) {
                        // Special cross-day showing (like P0 showing from Friday)
                        if (currentDay === periodConfig.showFromDay) {
                            const [hours, minutes] = periodConfig.showFromTime.split(':').map(Number);
                            showFromTime = hours * 60 + minutes;
                            if (currentMinutes >= showFromTime) {
                                // Show next school day's period
                                let nextDate = getNextSchoolDay(now);
                                return {period: p.period, date: nextDate, forceNextDay: true};
                            }
                        } else if (periodConfig.showUntilStart && CONFIG.schedule.schoolDays.includes(currentDay)) {
                            // Show until the period starts on its actual day
                            if (currentMinutes < p.start) {
                                period = p.period;
                                foundPeriod = true;
                                break;
                            }
                        }
                    } else if (periodConfig.showFromTime) {
                        // Period shows from a specific time on the same day
                        const [hours, minutes] = periodConfig.showFromTime.split(':').map(Number);
                        showFromTime = hours * 60 + minutes;
                        if (currentMinutes >= showFromTime && currentMinutes < p.end) {
                            period = p.period;
                            foundPeriod = true;
                            break;
                        }
                    }
                } else {
                    // Default behavior: show period X minutes before start time
                    showFromTime = p.start - CONFIG.schedule.defaultShowMinutesBefore;
                    if (currentMinutes >= showFromTime && currentMinutes < p.end) {
                        period = p.period;
                        foundPeriod = true;
                        break;
                    }
                }
            }
            
            // If no current period found, determine what to show
            if (!foundPeriod) {
                // Find the last period end time
                const lastPeriodEnd = Math.max(...sortedBellTimes.map(p => p.end));
                
                if (currentMinutes >= lastPeriodEnd) {
                    // After last period: show first period for next school day
                    let nextDate = getNextSchoolDay(now);
                    const firstPeriod = sortedBellTimes.length ? sortedBellTimes[0].period : "P0";
                    return {period: firstPeriod, date: nextDate, forceNextDay: true};
                } else {
                    // Before any period starts: show first period
                    period = sortedBellTimes.length ? sortedBellTimes[0].period : "No Period";
                }
            }
            
            return {period, date: now, forceNextDay: false};
        }

        // Check if lessons contain any classes for configured display years
        function hasClassesForYears7to12(lessonsByYear) {
            if (!CONFIG || !CONFIG.yearGroups.displayYears) {
                return ['7', '8', '9', '10', '11', '12'].some(year => 
                    lessonsByYear[year] && lessonsByYear[year].length > 0
                );
            }
            
            return CONFIG.yearGroups.displayYears.some(year => 
                lessonsByYear[year.toString()] && lessonsByYear[year.toString()].length > 0
            );
        }

        // Get the next period in sequence
        function getNextPeriod(bellTimes, currentPeriod, currentDate) {
            const sortedBellTimes = bellTimes.slice().sort((a, b) => a.start - b.start);
            
            // Find current period index
            let currentIndex = sortedBellTimes.findIndex(p => p.period === currentPeriod);
            
            if (currentIndex === -1) {
                // Period not found, return first period of next day
                let nextDate = getNextSchoolDay(currentDate);
                return {
                    period: sortedBellTimes[0].period,
                    date: nextDate,
                    forceNextDay: true
                };
            }
            
            // Find the next period with a DIFFERENT name
            for (let i = currentIndex + 1; i < sortedBellTimes.length; i++) {
                if (sortedBellTimes[i].period !== currentPeriod) {
                    return {
                        period: sortedBellTimes[i].period,
                        date: currentDate,
                        forceNextDay: false
                    };
                }
            }
            
            // If we reach here, we're at the end or all remaining periods are the same
            // Go to next day's first period
            let nextDate = getNextSchoolDay(currentDate);
            return {
                period: sortedBellTimes[0].period,
                date: nextDate,
                forceNextDay: true
            };
        }

        // --- RENDER ---
        function renderHeader(period, dateObj, forceNextDay) {
            // Convert period to display name using config
            let periodLabel = period || "No Period";
            if (CONFIG && CONFIG.schedule.periods[period] && CONFIG.schedule.periods[period].description) {
                periodLabel = CONFIG.schedule.periods[period].description;
            } else if (period && period.match(/^P\d+$/)) {
                const periodNumber = period.substring(1); // Remove 'P' prefix
                periodLabel = `Period ${periodNumber}`;
            }
            
            const currentDay = dateObj.getDay();
            
            let datePrefix = "";
            if (forceNextDay) {
                // Use config to determine appropriate prefix
                if (CONFIG && CONFIG.schedule.ignoredDays.includes(currentDay - 1)) {
                    datePrefix = "Next: ";
                } else {
                    datePrefix = "Next: ";
                }
            }
            
            const dateLabel = datePrefix + longDay(dateObj) + " " + auDate(dateObj);
            
            document.getElementById('header').innerHTML = `<h2>${periodLabel} - ${dateLabel}</h2>`;
            
            // Update current time display
            const now = getCurrentTime();
            const currentTime = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
            const timeLabel = USE_MANUAL_OVERRIDE ? `‚ö†Ô∏è MANUAL OVERRIDE: ${currentTime}` : `Current time: ${currentTime}`;
            
            const timeElement = document.getElementById('current-time');
            timeElement.innerHTML = timeLabel;
            timeElement.className = USE_MANUAL_OVERRIDE ? 'manual-override' : '';
        }
        
        function renderTimetable(lessonsByYear, currentPeriod, targetDate, calendarData) {
            if (!CONFIG) return;
            
            // Check if this is a sport period using config
            const isSportPeriod = isConfiguredSportPeriod(calendarData, targetDate, currentPeriod);
            
            let html = "";
            
            // Iterate through configured display years
            for (const yearNum of CONFIG.yearGroups.displayYears) {
                const year = yearNum.toString();
                
                if (!lessonsByYear[year]) continue;
                
                // Check if this year should be hidden during sport periods
                if (isSportPeriod && shouldExcludeYearFromSport(year, calendarData, targetDate, currentPeriod)) {
                    continue;
                }
                
                const isMultiRowYear = CONFIG.yearGroups.multiRowYears.includes(yearNum);
                const tilesClass = isMultiRowYear ? 'tiles multi-row' : 'tiles';
                
                // Determine the year label based on context
                let yearLabel = `Year ${year}`;
                
                if (isSportPeriod) {
                    // Check for sport period configurations
                    const calendarEntry = calendarData.find(entry => {
                        const entryDate = new Date(entry.date);
                        return entryDate.toDateString() === targetDate.toDateString();
                    });
                    
                    if (calendarEntry) {
                        for (const [dayKey, sportConfig] of Object.entries(CONFIG.sportPeriods)) {
                            if (calendarEntry.dayName.toLowerCase().includes(dayKey) && 
                                sportConfig.periods.includes(currentPeriod)) {
                                
                                // Check if this year has a special sport label
                                const sportGroup = sportConfig.yearGroups[year];
                                if (sportGroup && sportGroup.label) {
                                    yearLabel = sportGroup.label;
                                }
                            }
                        }
                    }
                }
                
                html += `<div class="year-section">
                    <span class="year-label">${yearLabel}</span>
                    <div class="${tilesClass}">`;
                    
                const lessons = lessonsByYear[year];
                if (lessons && lessons.length > 0) {
                    for (const lesson of lessons) {
                        html += `<div class="tile">
                            <div class="classcode">${(lesson.ClassCode||"").substring(0,7)}</div>
                            <div class="room">${lesson.RoomCode||""}</div>
                            <div class="teacher">${lesson.TeacherCode||""}</div>
                        </div>`;
                    }
                } else {
                    html += `<span class="empty-row">No classes</span>`;
                }
                html += `</div></div>`;
            }
            document.getElementById('timetable').innerHTML = html;
        }

        // --- MAIN ---
        let bellTimes = [];
        let lessonsXML = null;
        let calendarData = [];
        
        async function main() {
            // Load configuration first
            if (!CONFIG) {
                await loadConfig();
            }
            
            const now = getCurrentTime();

            if (bellTimes.length && lessonsXML && calendarData.length) {
                let periodObj = getCurrentPeriodOrNext(bellTimes, now);

                // Try to find a period with actual classes
                let lessonsByYear = parseLessons(lessonsXML, periodObj.period, calendarData, periodObj.date);
                let attempts = 0;
                const maxAttempts = bellTimes.length;
                
                // Check if current period has any classes for configured display years
                while (attempts < maxAttempts && !hasClassesForYears7to12(lessonsByYear)) {
                    // Get the next period
                    periodObj = getNextPeriod(bellTimes, periodObj.period, periodObj.date);
                    lessonsByYear = parseLessons(lessonsXML, periodObj.period, calendarData, periodObj.date);
                    attempts++;
                }
                
                renderHeader(periodObj.period, periodObj.date, periodObj.forceNextDay);
                renderTimetable(lessonsByYear, periodObj.period, periodObj.date, calendarData);
            } else {
                document.getElementById('header').innerHTML = "<h2>Loading data...</h2>";
                
                // Load configuration if not already loaded
                if (!CONFIG) {
                    await loadConfig();
                }
                
                // Load data files
                
                // Load data files
                Promise.all([
                    loadBellTimesData(), // Use new dual-source bell times loader
                    loadLissData(), // Use new dual-source LISS loader (JSON/XML)
                    loadCalendarData() // Use dual-source calendar loader
                ]).then(([bellTimesFromSource, lessonsXMLData, calendarDataFromSource]) => {
                    debugLog('üîß MAIN DEBUG: All data loading completed successfully');
                    
                    bellTimes = bellTimesFromSource;
                    lessonsXML = lessonsXMLData;
                    calendarData = calendarDataFromSource;
                    
                    debugLog(`üìä MAIN DEBUG: Loaded ${bellTimes.length} bell time periods`);
                    debugLog(`üìä MAIN DEBUG: Loaded ${calendarData.length} calendar entries`);
                    
                    if(bellTimes.length === 0) {
                        document.getElementById('header').innerHTML = "<h2>Error: No bell times found</h2>";
                        return;
                    }
                    
                    if(calendarData.length === 0) {
                        document.getElementById('header').innerHTML = "<h2>Error: No calendar data found</h2>";
                        return;
                    }
                    
                    // Show source information with enhanced debugging
                    const bellTimesSource = bellTimes[0]?.source || 'unknown';
                    const bellTimesSourceLabel = bellTimesSource === 'api' ? 'JSON (Sentral API)' : bellTimesSource === 'xml' ? 'XML (bell_times.xml)' : bellTimesSource;
                    
                    const calendarSource = calendarData[0]?.source || 'unknown';
                    const calendarSourceLabel = calendarSource === 'api' ? 'JSON (Sentral API)' : calendarSource === 'xml' ? 'XML (calendar.xml)' : calendarSource;
                    
                    const lissSource = lessonsXML?.lissSource || 'xml';
                    const lissSourceLabel = lissSource === 'api' ? 'JSON (Sentral API)' : lissSource === 'xml' ? 'XML (liss_info.xml)' : lissSource;
                    
                    debugLog(`üéØ MAIN DEBUG: ===== DATA SOURCE DECISIONS =====`);
                    debugLog(`‚è∞ MAIN DEBUG: Using bell times from: ${bellTimesSourceLabel}`);
                    debugLog(`üìÖ MAIN DEBUG: Using calendar data from: ${calendarSourceLabel}`);
                    debugLog(`üìö MAIN DEBUG: Using LISS data from: ${lissSourceLabel}`);
                    debugLog(`üìä MAIN DEBUG: Bell times date range: First period - ${bellTimes[0]?.period}`);
                    debugLog(`ÔøΩ MAIN DEBUG: Calendar date range: ${calendarData[0]?.date} to ${calendarData[calendarData.length-1]?.date}`);
                    debugLog(`üéØ MAIN DEBUG: ===================================`);
                    
                    main();
                }).catch(e=>{
                    console.error("Error loading data:", e);
                    
                    let errorMessage = "<h2>Error loading XML files</h2>";
                    let helpText = "";
                    
                    if (e.message.includes('CORS')) {
                        helpText = `
                            <div style="text-align: center; padding: 20px; color: #666; max-width: 600px; margin: 0 auto;">
                                <p><strong>CORS Policy Error:</strong> Modern browsers block local file access for security reasons.</p>
                                <p><strong>To run this application locally, you need to use a web server:</strong></p>
                                <div style="text-align: left; background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0;">
                                    <p><strong>Option 1 - Python (if installed):</strong></p>
                                    <code>python -m http.server 8000</code><br>
                                    <small>Then open: http://localhost:8000</small>
                                    
                                    <p style="margin-top: 15px;"><strong>Option 2 - Node.js (if installed):</strong></p>
                                    <code>npx http-server</code><br>
                                    <small>Then open the provided URL</small>
                                    
                                    <p style="margin-top: 15px;"><strong>Option 3 - PHP (if installed):</strong></p>
                                    <code>php -S localhost:8000</code><br>
                                    <small>Then open: http://localhost:8000</small>
                                    
                                    <p style="margin-top: 15px;"><strong>Option 4 - VS Code Live Server:</strong></p>
                                    <small>Install "Live Server" extension and right-click index.html ‚Üí "Open with Live Server"</small>
                                </div>
                                <p>Make sure config.json and XML files are in the same folder as index.html</p>
                            </div>`;
                    } else {
                        helpText = `
                            <div style="text-align: center; padding: 20px; color: #666;">
                                <p>Unable to load timetable data.</p>
                                <p>Please ensure config.json and XML files are in the same folder.</p>
                                <p>Error: ${e.message}</p>
                            </div>`;
                    }
                    
                    document.getElementById('header').innerHTML = errorMessage;
                    document.getElementById('timetable').innerHTML = helpText;
                });
            }
        }

        // ---- AUTO-RELOAD ----
        // Show/hide loading indicator
        function showLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) {
                indicator.classList.add('visible');
                indicator.style.opacity = '1';
            }
        }
        
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) {
                indicator.classList.remove('visible');
                indicator.style.opacity = '0';
            }
        }
        
        // Smooth data refresh without page flash
        function setupAutoReload() {
            // Check if auto-refresh is disabled in config
            if (CONFIG?.ui?.autoRefresh === false) {
                debugLog('üîÑ AUTO-RELOAD: Disabled by configuration');
                return;
            }
            
            if (CONFIG && CONFIG.ui.refreshInterval) {
                debugLog(`üîÑ AUTO-RELOAD: Setting up ${CONFIG.ui.refreshInterval / 1000}s refresh interval`);
                setInterval(async () => {
                    // Smooth reload: just re-run main() to refresh data
                    await smoothDataRefresh();
                }, CONFIG.ui.refreshInterval);
            } else {
                // Default fallback: refresh every minute
                debugLog('üîÑ AUTO-RELOAD: Using default 60s refresh interval');
                setInterval(async () => {
                    await smoothDataRefresh();
                }, 60000);
            }
        }

        // Perform a smooth data refresh with visual feedback
        async function smoothDataRefresh() {
            try {
                showLoadingIndicator();
                
                // Add slight fade effect to indicate update
                const timeElement = document.getElementById('current-time');
                if (timeElement) {
                    timeElement.classList.add('updating');
                }
                
                // Reset data to force reload
                bellTimes = [];
                lessonsXML = null;
                calendarData = [];
                
                // Re-run main function to refresh data
                await main();
                
                // Remove update indicators
                if (timeElement) {
                    timeElement.classList.remove('updating');
                }
                
            } catch (error) {
                console.error('Error during smooth refresh:', error);
            } finally {
                hideLoadingIndicator();
            }
        }

        // Optional: Full page reload every hour to prevent memory leaks
        function setupHourlyReload() {
            const hourlyInterval = CONFIG?.ui?.hourlyReload !== false ? 3600000 : null; // 1 hour, can be disabled
            
            if (hourlyInterval) {
                setInterval(() => {
                    // Only do full page reload once per hour to clear any memory leaks
                    location.replace(location.href);
                }, hourlyInterval);
            }
        }

        // Daily full page reload at 7:30am to start fresh each morning
        function setupDailyReload() {
            const now = new Date();
            const target = new Date();
            target.setHours(7, 30, 0, 0); // 7:30:00 AM
            
            // If 7:30am has already passed today, schedule for tomorrow
            if (now > target) {
                target.setDate(target.getDate() + 1);
            }
            
            const timeUntilReload = target.getTime() - now.getTime();
            
            debugLog(`üîÑ DAILY RELOAD: Scheduled for ${target.toLocaleString()}`);
            
            setTimeout(() => {
                debugLog('üåÖ DAILY RELOAD: Executing 7:30am fresh start');
                location.replace(location.href);
            }, timeUntilReload);
            
            // Also set up recurring daily reloads (every 24 hours)
            setInterval(() => {
                debugLog('üåÖ DAILY RELOAD: Executing recurring 7:30am fresh start');
                location.replace(location.href);
            }, 24 * 60 * 60 * 1000); // 24 hours
        }

        // Initialize the application
        async function init() {
            await loadConfig();
            setupAutoReload();
            setupHourlyReload(); // Optional full page reload every hour
            setupDailyReload(); // Daily full page reload at 7:30am
            main();
        }

        init();
    </script>
</body>
</html>
